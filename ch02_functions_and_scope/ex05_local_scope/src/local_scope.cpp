/**
 *
 * Object Lifetime and Destruction
 *
 * When a variable is instantiated, it is important to know when it is
 * *destroyed*, i.e., no longer available for use.
 *
 * Variables are instantiated when we initialize them or when we pass arguments
 * to a function and the compiler initializes them upon function
 * initialization.
 *
 * All *objects* including variables have a *lifetime*. The lifetime of an
 * object is the time between when it is created and destroyed. It is
 * important to remember that in C++ variable initialization and destruction
 * happen at runtime (i.e., when the program is running) not at compile time.
 *
 * Note: the C++ specification provides compilers flexibility to determine
 * when local variables are created and destroyed. This enables compilers to
 * implement optimizations under the hood. Variables are usually created when
 * the function is entered and destroyed in the opposite order of creation.
 *
 * In most cases, when an object is destroyed, nothing happens. The object is
 * just no longer valid. For this reason, no extra performance cost is
 * incurred when a variable is destroyed.
 *
 * Note, however, that in cases where user code can attempt to use an object
 * after it is destroyed this means the result is undefined behavior. The
 * object may still be present in memory which could make it appear the program
 * runs OK until in some cases the object becomes corrupted before the
 * post-destruction use and the program crashes for seemingly no reason.
 *
 * If the object is a class, a special function called a destructor is called
 * that performs cleanup.
 *
 *
 * Local Scope
 *
 * An identifier's (name for an object) *scope* determines where the identifier
 * can be seen and used. When an identifier can be used, it is *in scope*.
 * Scope is checked when a program is compiled and trying to use a variable out
 * of scope will cause a program to not compile. An identifier with local
 * scope (also called block scope) is usable from the point of definition to
 * the end of the innermost pair of curly braces containing the identifier.
 * The code between curly braces is called a *block*. Block scope ensures that
 * variables cannot before before they are initializes or after they are
 * destroyed.
 *
 * An identifier that can no longer be accessed is said to be "out of scope".
 * An object can be said to be "going out of scope" at the end of the scope
 * where it was instantiated.
 *
 * An identifier is said to be "out of scope" while an object is said to "go
 * out of scope".
 *
 *
 * Lifetime vs. Scope
 *
 * A local variable's lifetime ends when it goes out of scope, but this is not
 * true for all objects. Lifetime is a runtime property and scope is a
 * compile time property. This means if an identifier is used out of scope
 * a program will not compile. However, if an attempt is made to use an
 * object after its lifetime has ended, this will cause a runtime error.
 *
 * Temporary Objects
 *
 * A temporary object is an unamed object that is used to hold a value that is
 * only needed for a short period of time. Temporary object are generated by
 * the compile when they are needed.
 */

#include <iostream>

int getValueFromUser()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

int add(int x, int y) // x and y for add() created here
{
    // add's x and y are visible / usable within this function only
    return x + y;
} // add's x and y go out of scope and are destroyed here

int main()
{
    // main's x and y are created here
    int x{5};
    int y{6};

    std::cout << x << " + " << y << " = " << add(x, y) << '\n';

    // This will create a temporary object / anonymous object with the value
    // returned by getValueFromUser()
    std::cout << getValueFromUser() << '\n';

} // main's x and y go out of scope here

/**
 * Best practices
 *
 * Define local variables as close to their first use as reasonable. Old C
 * compilers used to required local variables to be initialized at the top of
 * a program. This is no longer necessary.
 *
 * Know the difference between a variable and a function parameter. Use a
 * function parameter when the caller will pass data to the callee as an
 * argument. Use local variables inside a function if the values of those
 * variables does not need to be passed from the callee.
 *
 * Identify groups of repeated statements and make them into functions. Do
 * not copy and paste code to repeat functionality.
 *
 * Keep the job of functions simple. Each function should do one thing and do
 * it well.
 *
 * Keep functions short. If a function becomes too long, break it into smaller
 * functions. If you find yourself commenting groups of lines to say what they
 * do, this is a good sign the function needs to be broken up into smaller
 * functions with descriptive names so the comment is not needed.
 *
 *
 * Benefits of Functions
 *
 * Organization: Functions make code less complex by allowing it to be broken
 * up into more manageable chunks.
 *
 * Reusability: Functions enable code to be reused and enable programs to
 * follow the "DRY" ("Don't Repeat Yourself") rule.
 *
 * Testing: Functions can be tested as a component. If there is a problem with
 * the code, we can see which functions are failing their tests to identify
 * where changes need to be made.
 *
 * Extensibility: When we need to extend our program to handle a case it didn't
 * handle before, functions allow the change to be made in one place.
 *
 * Abstraction: Functions abstract the details of how to solve a problem from
 * the (much simpler) knowledge of knowing how to use the function that
 * solves the problem. To a call a function, we only need to know its name and
 * what parameters it expects. We can use a function written by another
 * author without having to have deep knowledge of their code.
 */